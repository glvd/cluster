package cluster

import (
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/goextension/log"
	"github.com/libp2p/go-libp2p-core/crypto"
	"github.com/libp2p/go-libp2p-core/peer"
)

// Identity defaults
const (
	DefaultConfigCrypto    = crypto.Ed25519
	DefaultConfigKeyLength = -1
)

// Identity represents identity of a cluster peer for communication,
// including the Consensus component.
type Identity struct {
	ID         peer.ID
	PrivateKey crypto.PrivKey
}

// identityJSON represents a Cluster peer identity as it will look when it is
// saved using JSON.
type identityJSON struct {
	ID         string `json:"id"`
	PrivateKey string `json:"private_key"`
}

// DefaultIdentity generates a random keypair for this identity.
func DefaultIdentity() (*Identity, error) {
	// pid and private key generation
	priv, pub, err := crypto.GenerateKeyPair(
		DefaultConfigCrypto,
		DefaultConfigKeyLength,
	)
	if err != nil {
		return nil, err
	}
	pid, err := peer.IDFromPublicKey(pub)
	if err != nil {
		return nil, err
	}
	return &Identity{
		ID:         pid,
		PrivateKey: priv,
	}, nil
}

func (ident *Identity) LoadJSON(raw []byte) error {
	// LoadJSON receives a raw json-formatted identity and
	// sets the Config fields from it. Note that it should be JSON
	// as generated by ToJSON().
	jID := &identityJSON{}
	err := json.Unmarshal(raw, jID)
	if err != nil {
		log.Error("Error unmarshaling cluster config")
		return err
	}

	return ident.applyIdentityJSON(jID)
}

func (ident *Identity) applyIdentityJSON(ijson *identityJSON) error {
	pid, err := peer.IDB58Decode(ijson.ID)
	if err != nil {
		err = fmt.Errorf("error decoding cluster ID: %s", err)
		return err
	}
	ident.ID = pid

	pkb, err := base64.StdEncoding.DecodeString(ijson.PrivateKey)
	if err != nil {
		err = fmt.Errorf("error decoding private_key: %s", err)
		return err
	}
	pKey, err := crypto.UnmarshalPrivateKey(pkb)
	if err != nil {
		err = fmt.Errorf("error parsing private_key ID: %s", err)
		return err
	}
	ident.PrivateKey = pKey

	return ident.Validate()
}

// Validate will check that the values of this identity
// seem to be working ones.
func (ident *Identity) Validate() error {
	if ident.ID == "" {
		return errors.New("identity ID not set")
	}

	if ident.PrivateKey == nil {
		return errors.New("no identity private_key set")
	}

	if !ident.ID.MatchesPrivateKey(ident.PrivateKey) {
		return errors.New("identity ID does not match the private_key")
	}
	return nil
}
